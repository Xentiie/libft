from bs4 import BeautifulSoup
import re
import requests
import sys
from cached_requests import cached_get

def to_bytes(txt):
    txt = txt.upper().strip()
    units = {"B": 1, "K": 1024, "M": 1024**2, "G": 1024**3, "T": 1024**4}
    
    if txt[-1] in units:
        return int(txt[:-1]) * units[txt[-1]]
    else:
        raise ValueError()

def tohex_singledigit(v: int):
    _hex = "0123456789ABCDEF"
    return _hex[v]

class TLB:
    pattern = r'[\(]?([ID])TLB:([0-9]+)E,([0-9KM/]+)p,([0-9F]+)A[\)]?.*'
    def __init__(self, txt):
        groups = re.fullmatch(TLB.pattern, txt).groups()
        self.is_data = "TRUE" if (groups[0] == "D") else "FALSE"
        self.entries = int(groups[1])
        try:
            self.size = to_bytes(groups[2])
        except ValueError:
            return False
        
        if (groups[3][0] == 'F'):
            self.associativity = "U8_MAX"
        else:
            self.associativity = int(groups[3])

    def is_tlb(txt):
        return re.fullmatch(TLB.pattern, txt) != None

class Cache:
    pattern = r'[\(]?L([0-9])([IDC]):([0-9]+[KMG]),([0-9]+)A,([0-9]+)L[\)]?.*'
    def __init__(self, txt):
        groups = re.fullmatch(Cache.pattern, txt).groups()
        self.level = int(groups[0])
        self.type = "FT_CPUID_CACHE_INSTRUCTION" if (groups[1] == "I") else "FT_CPUID_CACHE_DATA" if (groups[1] == "D") else "FT_CPUID_CACHE_UNIFIED"
        try:
            self.size = to_bytes(groups[2])
        except ValueError:
            return False
        if (groups[3][0] == 'F'):
            self.associativity = "U8_MAX"
        else:
            self.associativity = int(groups[3])
        self.line_size = int(groups[4])

    def is_cache(txt):
        return re.fullmatch(Cache.pattern, txt) != None

content = cached_get("https://en.wikipedia.org/wiki/CPUID").content
soup = BeautifulSoup(content, "html.parser")
tbody = soup.find('caption', string=lambda text: text and "CPUID EAX=2: Cache/TLB" in text).find_parent('table').find('tbody')
trs = tbody.find_all("tr", recursive=False)[1:-1]

print(f"/* Auto-generated by {sys.argv[0]}. Depends on \"cpuid_private.h\" */")
print("static bool table_lookup(U8 v, union _u_cpuid_cache_tlb *o)\n{")
print("\tswitch (v)\n\t{")

nothings=[]
xpos = 0
for tr in trs:
    ypos = 0
    for td in tr.find_all("td"):
        orig_txt = td.get_text(strip=True)
        txt = ''.join(orig_txt.split())

        if ((xpos == 0 and ypos == 0) or len(txt) == 0):
            pass
        elif (TLB.is_tlb(txt)):
            print(f"\tcase 0x{tohex_singledigit(xpos)}{tohex_singledigit(ypos)}:")
            tlb = TLB(txt)
            print("\t\to->t = (struct s_cpuid_tlb){ ", end="")
            print(f".is_data = {tlb.is_data}, ", end = "")
            print(f".entries_cnt = {tlb.entries}, ", end = "")
            print(f".page_size = {tlb.size}, ", end = "")
            print(f".associativity = {tlb.associativity}", end = "")
            print(" };")
            print("\t\treturn -1;")
        elif (Cache.is_cache(txt)):
            print(f"\tcase 0x{tohex_singledigit(xpos)}{tohex_singledigit(ypos)}:")
            cache = Cache(txt)
            print("\t\to->c = (struct s_cpuid_cache){ ", end="")
            print(f".level = {cache.level}, ", end = "")
            print(f".type = {cache.type}, ", end = "")
            print(f".size = {cache.size}, ", end = "")
            print(f".line_size = {cache.line_size}, ", end = "")
            print(f".associativity = {cache.associativity}", end = "")
            print(" };")
            print("\t\treturn -2;")
        else:
            print(f"\tcase 0x{tohex_singledigit(xpos)}{tohex_singledigit(ypos)}:")
            print("\t\t/* unknown string: */")
            print(f"\t\t/* '{txt}' */")
            print(f"\t\t/* '{orig_txt}' */")
            print("\t\treturn v;")
        ypos += 1
    xpos += 1

print("\tdefault:\n\t\treturn 0;")
print("\t}")
print("}\n")


