import clang.cindex
import sys
import json
import os

def get_function_signature(node) -> tuple[str, list[str]]:
    return_type = node.result_type.spelling
    parameters = []
    for param in node.get_arguments():
        param_name = param.spelling
        param_type = param.type.spelling
        parameters.append((param_name, param_type))
    return (return_type, parameters)

def format_arguments(args:list[tuple[str, str]]):
    return ', '.join([f'{s[1]} {s[0]}' for s in args])

def format_signature(signature:tuple[str, list[str]], func_name:str):
    return f"{signature[0]} {func_name}({format_arguments(signature[1])})"

class ExtendedAlias:
    target:str
    alias_name:str
    signature:tuple[str, list[str]]
    prio:int
    required_extensions:list[str]

    def __init__(self, target:str, alias_name:str, signature:tuple[str, list[str]], prio:int, required_extensions:list[str]):
        self.target = target
        self.alias_name = alias_name
        self.prio = prio
        self.required_extensions = required_extensions
        self.signature = signature

    def __str__(self):
        return f"ExtendedAlias({self.target}, {self.alias_name}, {format_signature(self.signature, self.target)}, {self.prio}, {self.required_extensions})"

    def __repr__(self):
        return str(self)



def find_aliases_in_file(filepath:str) -> list[ExtendedAlias]:
    index = clang.cindex.Index.create()
    tu = index.parse(filepath, ["-I./include", "-I./srcs"])
    aliases: list[str] = []
    for cursor in tu.cursor.get_children():
        if cursor.location.file and cursor.location.file.name != filepath:
            continue

        if cursor.kind == clang.cindex.CursorKind.FUNCTION_DECL:
            func_sign = get_function_signature(cursor)
            for child in cursor.get_children():
                if child.kind == clang.cindex.CursorKind.ANNOTATE_ATTR:
                    alias_name:str = cursor.spelling
                    annotation:str = child.displayname

                    try:
                        prefix, target, prio, *required_extensions = annotation.split(':')
                    except:
                        continue
                    if (prefix != "ft_extended_alias"):
                        continue
                    if (len(required_extensions) == 1 and required_extensions[0] == ""):
                        required_extensions = []
                    aliases.append(ExtendedAlias(target, alias_name, func_sign, int(prio), required_extensions))
    return aliases

if __name__ == "__main__":
    if (len(sys.argv) != 2):
        print("Usage: python3 extended_aliases.py filepath")
        exit(1)

    aliases = find_aliases_in_file(sys.argv[1])
    aliases_dict:dict[str, list[ExtendedAlias]] = {}
    for a in aliases:
        try:
            aliases_dict[a.target].append(a)
        except:
            aliases_dict[a.target] = [a]

    for k in aliases_dict:
       aliases_dict[k].sort(key=lambda alias: alias.prio, reverse=True)

    print(json.dumps(aliases_dict, default=str, indent=4), end="\n\n")

    _indent = 0
    def enter_scope_quiet():
        global _indent
        _indent += 1
    def exit_scope_quiet():
        global _indent
        _indent -= 1
    def enter_scope():
        print_indent("{")
        enter_scope_quiet()
    def exit_scope():
        exit_scope_quiet()
        print_indent("}")

    def print_indent(*args, indent=_indent, **kwargs):
        if (len(args) == 0):
            print()
            return
        print("\t" * indent, end="")
        print(*args, **kwargs)

    def print_no_nl(*args, **kwargs):
        print_indent(*args, **kwargs, end="")

    def if_debug_begin():
        print("#if defined(DEBUG)")
    def if_debug_end():
        print("#endif")

    def if_debug_print(*args, **kwargs):
        if_debug_begin()
        print(*args, **kwargs)
        if_debug_end()

    def if_ndebug_begin():
        print("#if !defined(DEBUG)")
    def if_ndebug_end():
        print("#endif")

    def if_ndebug_print(*args, **kwargs):
        if_ndebug_begin()
        print(*args, **kwargs)
        if_ndebug_end()

    def generate_include(include_path:str):
        return f"#include \"{include_path}\""

    def generate_condition(required_extensions:list[str]):
        flags = [f"flags->{e}" for e in required_extensions]
        return " && ".join(flags)

    print("CODE:")
    print_indent(f"/* Auto-generated by {os.path.relpath(__file__, os.getcwd())} */")
    print_indent(generate_include("libft/sys/cpuid.h"))
    if_debug_print(generate_include("libft/io.h"))
    print_indent()

    for k in aliases_dict:

        if (len(aliases_dict[k][-1].required_extensions) != 0):
            print(f"WARNING: '{aliases_dict[k][0].target}' has no default, skipping !")
            continue

        if_debug_print(f"static void *__resolved_{aliases_dict[k][0].target} = NULL;")
        print_indent(f"static {aliases_dict[k][0].signature[0]} (*resolve_{aliases_dict[k][0].target}(void))({format_arguments(aliases_dict[k][0].signature[1])})")
        enter_scope()

        if_ndebug_print(f"void *__resolved_{aliases_dict[k][0].target} = NULL;")
        print_indent("struct s_cpuid_flags *flags;")
        print_indent()
        print_indent("flags = ft_cpuid_get_cached_flags();")
        for i, alias in enumerate(aliases_dict[k]):

            if (i == 0):
                print_no_nl("if (")
                print_indent(generate_condition(alias.required_extensions) + ")", indent=0)
            elif (i == len(aliases_dict[k]) - 1):
                print_indent("else")
            else:
                print_no_nl("else if (")
                print_indent(generate_condition(alias.required_extensions) + ")", indent=0)

            enter_scope_quiet()
            print_indent(f"__resolved_{aliases_dict[k][0].target} = {alias.alias_name};")
            exit_scope_quiet()

        print_indent(f"return __resolved_{aliases_dict[k][0].target};")
        exit_scope()
        print_indent()
        print_indent(f"{format_signature(aliases_dict[k][0].signature, aliases_dict[k][0].target)}\n\t__attribute__((ifunc(\"resolve_{aliases_dict[k][0].target}\")));")
        print_indent()

    if_debug_begin()
    print_indent(f"__attribute__((constructor)) static void __debug_ifunc()")
    enter_scope()
    for k in aliases_dict:
        print_indent(f"ft_printf(\"{aliases_dict[k][0].target}:\");")
        for i, alias in enumerate(aliases_dict[k]):

            if (i == 0):
                print_indent(f"if (__resolved_{aliases_dict[k][0].target} == {alias.alias_name}) ft_printf(\"{alias.alias_name}\\n\");")
            elif (i == len(aliases_dict[k]) - 1):
                print_indent(f"else ft_printf(\"{alias.alias_name}\\n\");")
            else:
                print_indent(f"else if (__resolved_{aliases_dict[k][0].target} == {alias.alias_name}) ft_printf(\"{alias.alias_name}\\n\");")
    exit_scope()
    if_debug_end()
        
