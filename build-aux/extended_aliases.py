import clang.cindex
import sys
import json
import os
from collections import defaultdict


class CFunctionParam:
    def __init__(self, param):
        self.name = param.spelling
        self.type = param.type.spelling

class CFunction:
    def __init__(self, node: clang.cindex.Cursor):
        self.name = node.spelling
        self.return_type = node.result_type.spelling

        self.parameters: list[CFunctionParam] = []
        for param in node.get_arguments():
            self.parameters.append(CFunctionParam(param))

    def format_arguments(self):
        arguments_list = [f'{p.type} {p.name}' for p in self.parameters]
        return ', '.join(arguments_list)
        

    # Formats a C function signature
    def format_signature(self):
        arguments_list = [f'{p.type} {p.name}' for p in self.parameters]
        return f"{self.return_type} {self.name}({self.format_arguments()})"

class ExtendedAlias:
    target:str
    func:CFunction
    prio:int
    cpuid_flags:list[str]
    os_flags:list[str]

    def __init__(self, target:str, func: CFunction, prio:int, cpuid_flags:list[str], os_flags:list[str]):
        self.target = target
        self.func = func
        self.prio = prio
        self.cpuid_flags = cpuid_flags
        self.os_flags = os_flags

    # Formats the conditions (checks the required flags...)
    def format_conditions(self):
        if (len(self.os_flags) == 0 and len(self.cpuid_flags) == 0):
            return "1"
        flags = [f"os_flags.{e}" for e in self.os_flags] + [f"cpuid_flags->{e}" for e in self.cpuid_flags]
        return " && ".join(flags)

    def __str__(self):
        return f"ExtendedAlias({self.target}, {self.func.name}, {self.func.format_signature()}, {self.prio}, {self.cpuid_flags})"

    def __repr__(self):
        return str(self)

def find_aliases_in_file(filepath:str) -> list[ExtendedAlias]:
    index = clang.cindex.Index.create()

    root_path = os.path.relpath(os.getcwd(), os.path.dirname(os.path.dirname(__file__)))
    tu = index.parse(filepath, [f"-I{root_path}/include", f"-I{root_path}/srcs"])
    aliases: list[ExtendedAlias] = []
    for cursor in tu.cursor.get_children():
        if cursor.location.file and cursor.location.file.name != filepath:
            continue

        if cursor.kind == clang.cindex.CursorKind.FUNCTION_DECL: # type: ignore
            for child in cursor.get_children():
                if child.kind == clang.cindex.CursorKind.ANNOTATE_ATTR: # type: ignore
                    annotation:str = child.displayname

                    # Expected format
                    # ft_extended_alias:target:prio:cpuid_flag_1,cpuid_flag_2:os_flag_1,os_flag_2

                    #split the string
                    try:
                        prefix, target, prio, cpuid_flags, os_flags = annotation.split(':')
                        cpuid_flags = cpuid_flags.split(',')
                        os_flags = os_flags.split(',')
                    except:
                        continue

                    #validate prefix
                    if (prefix != "ft_extended_alias"):
                        continue

                    #handle empty lists
                    if (len(cpuid_flags) == 1 and cpuid_flags[0] == ""):
                        cpuid_flags = []
                    if (len(os_flags) == 1 and os_flags[0] == ""):
                        os_flags = []

                    new_alias = ExtendedAlias(target, CFunction(cursor), int(prio), cpuid_flags, os_flags)
                    aliases.append(ExtendedAlias(target, CFunction(cursor), int(prio), cpuid_flags, os_flags))
    return aliases

if __name__ == "__main__":
    if (len(sys.argv) != 2):
        print("Usage: python3 extended_aliases.py filepath")
        exit(1)

    aliases = find_aliases_in_file(sys.argv[1])
    aliases_dict:dict[str, list[ExtendedAlias]] = defaultdict(list)
    for a in aliases:
        aliases_dict[a.target].append(a)    

    for k in aliases_dict:
       aliases_dict[k].sort(key=lambda alias: alias.prio, reverse=True)

    print(json.dumps(aliases_dict, default=str, indent=4), end="\n\n")

    print(f"""Code:
/* Auto-generated by {os.path.relpath(__file__, os.getcwd())} */

#include "libft/sys/cpuid.h"
#include "libft/sys/xsave.h"
#include "libft/io.h"
""")

    for k in aliases_dict:

        if (len(aliases_dict[k][-1].cpuid_flags) != 0 or len(aliases_dict[k][-1].os_flags) != 0):
            print(f"WARNING: '{aliases_dict[k][0].target}' has no default, skipping !")
            continue

        print(f"""#if defined(DEBUG)
static void *__resolved_{aliases_dict[k][0].target} = NULL;
#endif
static {aliases_dict[k][0].func.return_type} (*resolve_{aliases_dict[k][0].target}(void))({aliases_dict[k][0].func.format_arguments()})
{{
""")

        print(f"""#if !defined(DEBUG)
\tvoid *__resolved_{aliases_dict[k][0].target} = NULL;
#endif
\tstruct s_cpuid_flags *cpuid_flags;
\tstruct s_xcr0_flags os_flags;

\tcpuid_flags = ft_cpuid_get_cached_flags();
\tft_xgetbv(0, &os_flags.flags);""")

        for i, alias in enumerate(aliases_dict[k]):

            if (i == 0):
                print(f"\tif ({alias.format_conditions()})")
            elif (i == len(aliases_dict[k]) - 1):
                print("\telse")
            else:
                print(f"\telse if ({alias.format_conditions()})")
            print(f"\t\t__resolved_{aliases_dict[k][0].target} = {alias.func.name};")

        print(f"""\treturn __resolved_{aliases_dict[k][0].target};
}}

{aliases_dict[k][0].func.return_type} {aliases_dict[k][0].target}({aliases_dict[k][0].func.format_arguments()})
    __attribute__((ifunc(\"resolve_{aliases_dict[k][0].target}\")));""")

    print(f"""
#if defined(DEBUG)
__attribute__((constructor)) static void __debug_ifunc()
{{""")
    for k in aliases_dict:
        print(f"\tft_printf(\"{aliases_dict[k][0].target}:\");")
    
        for i, alias in enumerate(aliases_dict[k]):
            if (i == 0):
                print(f"\tif (__resolved_{aliases_dict[k][0].target} == {alias.func.name})\n\t\tft_printf(\"{alias.func.name}\\n\");")
            elif (i == len(aliases_dict[k]) - 1):
                print(f"\telse\n\t\tft_printf(\"{alias.func.name}\\n\");")
            else:
                print(f"\telse if (__resolved_{aliases_dict[k][0].target} == {alias.func.name})\n\t\tft_printf(\"{alias.func.name}\\n\");")

    print("""
}
#endif
""")
